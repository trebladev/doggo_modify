---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by TerrorBlade.
--- DateTime: 2021/1/31 15:22
---
-- DO NOT WRITE CODE OUTSIDE OF THE if-then-end SECTIONS BELOW!! (unless the code is a function definition)





function changeGaitParams(params)
    GaitParams["stance_height"] = params[1]
    GaitParams["down_amp"] = params[2]
    GaitParams["up_amp"] = params[3]
    GaitParams["flight_percent"] = params[4]
    GaitParams["step_length"] = params[5]
    GaitParams["freq"] = params[6]
    GaitParams["step_diff"] = params[7]
end


--???????
--????????x?y
function SinTrajectory(params)
    local t_diff
    local stanceHeight = params.stance_height
    local downAMP = params.down_amp
    local upAMP = params.up_amp
    local flightPercent = params.flight_percent
    local stepLength = params.step_length
    local FREQ = params.freq

    local x,y

    t = sim.getSimulationTime()
    t_diff = t-prev_t


    p = p+FREQ*t_diff
    prev_t = t
    local gp = math.fmod(p,1.0)

    if(gp <= flightPercent)
    then
        x = (gp/flightPercent)*stepLength - stepLength/2.0
        y = upAMP*math.sin(math.pi*gp/flightPercent) + stanceHeight
    else
        local percentBack = (gp-flightPercent)/(1.0-flightPercent)
        x = percentBack*stepLength + stepLength/2.0
        y = downAMP*math.sin(math.pi*percentBack) + stanceHeight
    end
    --print(p)
    return x,y

end

--?????????x?y???????L?theta
--??L?theta
function CartesianToLegParams(x,y,leg_direction)
    local L,theta
    L = math.pow((math.pow(x,2.0) + math.pow(y,2.0)), 0.5)
    theta = math.atan2(leg_direction * x, y)
    return L,theta
end

--?????L?theta??????gamma?
--??gamma
function GetGamma(L,theta)
    local gamma
    local cos_param = (math.pow(L1,2.0) + math.pow(L,2.0) - math.pow(L2,2.0)) / (2.0*L1*L)
    if(cos_param < -1.0) then
        gamma = math.pi
    else
        gamma = math.acos(cos_param)

    end
    return theta,gamma
end


--????????x?y????????theta?gamma
--??theta?gamma
function CartesianToThetaGamma(x,y,leg_direction)
    local L,theta
    local gamma
    L,theta = CartesianToLegParams(x,y,leg_direction)
    gamma = GetGamma(L,theta)

    return theta,gamma
end



if (sim_call_type==sim.syscb_init) then
    motorHandle=sim.getObjectHandle("Revolute_joint")
    motorHandle0=sim.getObjectHandle("Revolute_joint0")
    -- Put some initialization code here

    -- Make sure you read the section on "Accessing general-type objects programmatically"
    -- For instance, if you wish to retrieve the handle of a scene object, use following instruction:
    --
    -- handle=sim.getObjectHandle('sceneObjectName')
    --
    -- Above instruction retrieves the handle of 'sceneObjectName' if this script's name has no '#' in it
    --
    -- If this script's name contains a '#' (e.g. 'someName#4'), then above instruction retrieves the handle of object 'sceneObjectName#4'
    -- This mechanism of handle retrieval is very convenient, since you don't need to adjust any code when a model is duplicated!
    -- So if the script's name (or rather the name of the object associated with this script) is:
    --
    -- 'someName', then the handle of 'sceneObjectName' is retrieved
    -- 'someName#0', then the handle of 'sceneObjectName#0' is retrieved
    -- 'someName#1', then the handle of 'sceneObjectName#1' is retrieved
    -- ...
    --
    -- If you always want to retrieve the same object's handle, no matter what, specify its full name, including a '#':
    --
    -- handle=sim.getObjectHandle('sceneObjectName#') always retrieves the handle of object 'sceneObjectName'
    -- handle=sim.getObjectHandle('sceneObjectName#0') always retrieves the handle of object 'sceneObjectName#0'
    -- handle=sim.getObjectHandle('sceneObjectName#1') always retrieves the handle of object 'sceneObjectName#1'
    -- ...
    --
    -- Refer also to simGetCollisionhandle, sim.getDistanceHandle, sim.getIkGroupHandle, etc.
    --
    -- Following 2 instructions might also be useful: sim.getNameSuffix and sim.setNameSuffix
    require "math"
    L1 = 0.09
    L2 = 0.162
    p = 0
    prev_t = 0

    GaitParams = {}
    GaitParams["stance_height"] = 0.18
    GaitParams["down_amp"] = 0.00
    GaitParams["up_amp"] = 0.06
    GaitParams["flight_percent"] = 0.6
    GaitParams["step_length"] = 0.00
    GaitParams["freq"] = 1.0
    GaitParams["step_diff"] = 0.00

    state_gait_params = {
        {NAN, NAN, NAN, NAN, NAN, NAN, NAN}, -- STOP
        {0.17, 0.04, 0.06, 0.35, 0.15, 2.0, 0.0}, -- TROT
        {0.17, 0.04, 0.06, 0.35, 0.0, 2.0, 0.0}, -- BOUND
        {0.15, 0.00, 0.06, 0.25, 0.0, 1.5, 0.0}, -- WALK
        {0.12, 0.05, 0.0, 0.75, 0.0, 1.0, 0.0}, -- PRONK
        {NAN, NAN, NAN, NAN, NAN, NAN, NAN}, -- JUMP
        {0.15, 0.05, 0.05, 0.35, 0.0, 1.5, 0.0}, -- DANCE
        {0.15, 0.05, 0.05, 0.2, 0.0, 1.0, 0.0}, -- HOP
        {NAN, NAN, NAN, NAN, NAN, 1.0, NAN}, -- TEST
        {NAN, NAN, NAN, NAN, NAN, NAN, NAN}, -- ROTATE
        {0.15, 0.07, 0.06, 0.2, 0.0, 1.0, 0.0}, -- FLIP
        {0.17, 0.04, 0.06, 0.35, 0.1, 2.0, 0.06}, -- TURN_TROT
        {NAN, NAN, NAN, NAN, NAN, NAN, NAN} -- RESET
    }
    changeGaitParams(state_gait_params[2])

end


if (sim_call_type==sim.syscb_actuation) then
    --sim.setJointTargetVelocity(motorHandle, -0.1)
    --sim.setJointTargetVelocity(motorHandle0, 0.15)
    targetPosition=sim.getJointPosition(motorHandle)
    targetPosition0=sim.getJointPosition(motorHandle0)
    --[[
    if (math.abs(targetPosition0)<0.01 and math.abs(targetPosition)<0.01) then
        sim.setJointTargetPosition(motorHandle,-0.5)
        sim.setJointTargetPosition(motorHandle0,-0.5)
    end
    ]]--
    --if (targetPosition>-0.1) then
    --  sim.setJointTargetPosition(motorHandle,-1)
    --end
    --[[
    if (math.abs(0.5+targetPosition0)<0.01 and math.abs(0.5+targetPosition)<0.01) then
        sim.setJointTargetPosition(motorHandle0,0)
        --sim.setJointTargetPosition(motorHandle,0)
    end

    if (math.abs(targetPosition0)<0.01 and math.abs(0.5+targetPosition)<0.01) then
        sim.setJointTargetPosition(motorHandle,0)
     --   sim.setJointTargetPosition(motorHandle0,0)
    end
    ]]--
    --if (targetPosition+1<0.1) then
    --  sim.setJointTargetPosition(motorHandle,0)
    --end
    -- Put your main ACTUATION code here

    -- For example:
    --
    -- local position=sim.getObjectPosition(handle,-1)
    -- position[1]=position[1]+0.001
    -- sim.setObjectPosition(handle,-1,position)

    x,y = SinTrajectory(GaitParams)
    theta,gamma = CartesianToThetaGamma(x,y,1)
    sim.setJointPosition(motorHandle0,theta*1000/360*2*math.pi)
    sim.setJointPosition(motorHandle,gamma*1000/360*2*math.pi)


end


if (sim_call_type==sim.syscb_sensing) then

    -- Put your main SENSING code here

end


if (sim_call_type==sim.syscb_cleanup) then

    -- Put some restoration code here

end